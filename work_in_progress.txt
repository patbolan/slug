20250831
Got the options working. Now the options are defined by the properties command.
The run and undo commands must work with all of the options.

The config file needs a list of tools. 

20250826
Working great. I have a prototype going that runs inline or blocking, captures all the 
outputs in the correct folder. Much simpler than before. Next steps in this:
X use the correct process folders. Make sure the "Process" pages work right. 

* Implement autotagger as module. Add an option to undo (preserve). Then work on options
* Pass the options correctly. Especially the execution
* Do you need to get the options from command line? 

* Make a simple project and study module. Figure out the json options
* Clean up lots of code. 
* preload the modules

Before you give back to Leo, implement autotagger and parse dicom as modules.

Note I made it so that the module_definitions.csv files just look up folder and script
It's the config files that tell you which tools to present


--------------------

Major revision of the tools/modules/processes
First, let's get the new module structure to look at the correct folder. 
Implement only nii_converter first

Need to revise the way processes are run. Too complicated. 
Right now here is the path:

main routes
    utils.get_tool_menu
        uses wrapper to get deets and return GUI get_tool_menu

Running is like this:
tool routes, command
    tools.utils.execute_module_tool
        creates wrapper
        wrapper.run_in_subprocess
            creates PM
            PM.spawn process(wrapper)
                makes a Process object
                    wrapper.run_coimmand_line
                        build command line string
                        subporcess.run()

That all works, but it is too many cooks!
minimize this. In the route, assemble what you need. Call it.

Using copilot I made a function run_commandline() in pm that does most everything. 

I think CSV just maps name to script. Then properties tells you the scope, etc






A few ideas
X get the nii-converter code updated - CHECK
* subject types are human, phantom, Study types are human-mri, phantom-mri


Lots of stuff. Need a new tool base, module_base. You give it a name, and pass in 
default options. 

Actually, at startup it should load the CSV files to get a list of modules. Then for 
each, try to call get_proprties, and save all that info. Some commands will not be 
available.

When you are loading eg a study page, figure out the type, get the list of all possible
modules to display. Create an object for each. That constructor will call commandline
status. Thos results will be packaged up as needed for the GUI, along with PIDs if 
possible. 

Need to test options in the GUI

Then if you click run or undo. That object is re-constructed, and executed.

Consider modifying the saved PID folders. Name them as PID_modulename_targetname. 
Then it will be way easier to look at those logs to see what's beenrun

It loads the CSV file (should do this once) and gets the folder and script name
Calls properites 

Proably need a separate route to list the modules that are avilablle. You can 
"test" each one, to get status, properties.


Then go back and pull your python code out into modules (autotag, parse_dicom)

